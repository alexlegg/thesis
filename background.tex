\chapter{Background}

Synthesis is a process that demands mathematical formalisation in order to
provide a strong guarantee of the correctness of the resultant software. As
such we require a mathematical language to describe the system we wish to
produce, the environment in which it operates, and the properties we want the
system to adhere to. This chapter will outline that language and the ways we
can reason about what we describe in it.

\section{Reactive Systems}

Devices drivers are an example of a reactive system. A reactive system is a
system that is in a continuous process of responding to input from its
environment. A driver accepts requests from the operating system and state
information from the device, and it responds by sending commands to the device
and reporting to the operating system.

\section{Kripke Structures}

A reactive system can be thought of as a sequence of \emph{states}. The system
\emph{transitions} between these states as it responds to its inputs. A Kripke
structure~\cite{Kripke63} formalises this notion and provides us will the
language to reason about a reactive system.

A Kripe structure $M$ is defined by the tuple $M = (S, S_0, R, L)$ with respect
to a set of atomic propositions $AP$.

\begin{itemize}
    \item A finite set of states, $S$,
    \item a subset of initial stats $S_0 \subseteq S$,
    \item a transition relation $R \subseteq S \times S$, and
    \item a labelling function $L : S \to 2^{AP}$.
\end{itemize}

The transition relation defines how the system moves between states. It must be
left-total, i.e. for every $s \in S$ there is an $s' \in S$ s.t. $R(s, s')$.
The labelling function maps every state in $S$ to a set of atomic propositions
that hold in that state of the system.

We often consider \emph{paths} or \emph{runs} of a Kripke structure. A path is
a sequence of states $\pi = s_0, s_1, s_2, ...$ such that $R(s_i, s_{i+1})$
holds for all $i \geq 0$.

\section{Temporal Logic}

Kripke structures lay the groundwork for reasoning about reactive systems.
Using the labelling function we may define desirable properties for the system.
What is now lacking is a means of bringing states together to reason about the
system as a whole. This requires a logical language that can express temporal
properties.

Temporal logic takes propositional logic and provides additional semantics for
the concept of time. In a Kripke structure this refers to the expressiveness to
reason about runs of the system. This allows us to define properties that must
be true for the entire execution of a reactive system.

Linear temporal logic (LTL) allows for statements that refer to a single run of
a Kripke structure. Pnueli introduced LTL in 1977~\cite{Pnueli77} to succinctly
describe the outcomes of program execution by referring to global invariants
and eventualities. The syntax is:

\begin{itemize}
    \item $\phi$ is a propositional formula referring to the current state,
    \item $X\phi$ - $\phi$ is true in the next state of the execution,
    \item $F\phi$ - Eventually (finally) $\phi$ will be true, and
    \item $G\phi$ - $\phi$ is always (globally) true.
    \item $\phi_1 U \phi_2$ - $\phi_1$ holds until $\phi_2$ holds.
\end{itemize}

These operators are semantically defined with respect to a Kripke structure $M
= (S, S_0, R, L)$. We use $M, s \models \phi$ to denote $\phi$ holds true at
state $s \in S$ of structure $M$. We definte $\models$ recursively:

\begin{itemize}
    \item $M, s \models \phi$ iff $\phi \in L(s)$.
    \item $M, s \models \lnot\phi$ iff not $(M, s \models \phi)$.
    \item $M, s \models \phi_1 \land \phi_2$ iff $(M, s \models \phi_1) \land (M, s \models \phi_2)$.
    \item $M, s \models \phi_1 \lor \phi_2$ iff $(M, s \models \phi_1) \lor (M, s \models \phi_2)$.
    \item $M, s \models X\phi$ iff for some state $s'$, $R(s, s') \land M, s' \models \phi$.
    \item $M, s_0 \models F\phi$ iff for some path $(s_0, s_1, ...)$, $\exists i (i \geq 0 \land (M, s_i \models \phi))$.
    \item $M, s_0 \models G\phi$ iff for some path $(s_0, s_1, ...)$, $\forall i (i \geq 0 \land (M, s_i \models \phi))$.
    \item $M, s_0 \models \phi_1 U \phi_2$ iff for some path $(s_0, s_1, ...)$, $\exists i (i \geq 0 \land (M, s_i \models \phi_2) \land \forall j (j \geq 0 \land g < i \to (M, s_j \models \phi_1)))$.
\end{itemize}

Throughout this thesis will use $F$ and $G$ to represent the \emph{finally} and
\emph{globally} operators. Elsewhere in the literature $\lozenge$ and $\square$
are sometimes used to represent the same.

In addition to LTL, which is used to formalise properties about a single
execution trace, we may need the ability to talk about aggregations of traces.
In 1981 Clarke introduced computation tree logic (CTL)~\cite{Clarke81}, which
has additional syntax and semantics for exactly that. The syntax of CTL is as
follows:

\begin{itemize}
    \item $A\phi$ - $\phi$ is true on all paths
    \item $E\phi$ - there exists a path on which $p$ is true
\end{itemize}

We again define the semantics of CTL with respect to a Kripke structure $M =
(S, S_0, R, L)$.

\begin{itemize}
    \item $M, s \models \phi$ iff $\phi \in L(s)$.
    \item $M, s \models \lnot\phi$ iff $\lnot (M, s \models \phi)$.
    \item $M, s \models \phi_1 \land \phi_2$ iff $(M, s \models \phi_1) \land (M, s \models \phi_2)$.
    \item $M, s \models \phi_1 \lor \phi_2$ iff $(M, s \models \phi_1) \lor (M, s \models \phi_2)$.
    \item $M, s \models EX\phi$ iff for some state $s'$, $R(s, s') \land M, s' \models \phi$.
    \item $M, s \models AX\phi$ iff for all states $s'$, $R(s, s') \to M, s' \models \phi$.
    \item $M, s_0 \models A[\phi_1 U \phi_2]$ iff for all paths $(s_0, s_1, ...)$, $\exists i (i \geq 0 \land (M, s_i \models \phi_2) \land \forall j (j \geq 0 \land g < i \to (M, s_j \models \phi_1)))$.
    \item $M, s_0 \models E[\phi_1 U \phi_2]$ iff for some path $(s_0, s_1, ...)$, $\exists i (i \geq 0 \land (M, s_i \models \phi_2) \land \forall j (j \geq 0 \land g < i \to (M, s_j \models \phi_1)))$.
    \item $(M, s \models AF\phi) \Leftrightarrow (M, s \models A[\top U \phi])$
    \item $(M, s \models EF\phi) \Leftrightarrow (M, s \models E[\top U \phi])$
    \item $(M, s \models AG\phi) \Leftrightarrow (M, s \models \lnot EF (\lnot \phi))$
    \item $(M, s \models EG\phi) \Leftrightarrow (M, s \models \lnot AF (\lnot \phi))$
%%%    \item $M, s_0 \models AG\phi$ iff For all paths $(s_0, s_1, ...)$, $\forall i (i \geq 0 \land (M, s_i \models \phi))$.
\end{itemize}

In CTL, each $A$ or $E$ must be paired with an LTL operator. For example
$AG\phi$, which says that $\phi$ must always hold on all paths. Alternatively,
CTL* allows for free mixing of operators from LTL and CTL. This allows for
terms such as $E(GF\phi)$, which is true iff there exists a path where $\phi$
will always be true at some future state.

\section{Model Checking}

Once the desirable properties of a system have be laid out in temporal logic,
the next step is to verify that a program adheres to its specification. One
approach is to manually (or with the assistance of a proof checker) construct a
proof for the program. However, this costs the verifier in both time and mental
effort and so a mechanised approach is desired. The first such automatic
\emph{model checker} was proposed by Clarke et al.~\cite{Clarke86} to verify
temporal properties of finite state programs. The algorithm they proposed was a
search based labelling of a finite state-transition graph, representing the
program, with subformulas of the temporal logic specification. 

Another approach is based on the notion that temporal logic properties can be
expressed in terms of automata theory. Specifically, a finite state automaton
over infinite words can be used to represent a temporal logic formula. B\"uchi
automata~\cite{Buchi62} are $\omega$-automata, i.e. finite automata that accept
an infinite stream of input, which may be constructed such that the automaton
will accept exactly the inputs allowable by a temporal logic formula.

In \cite{Vardi96}, the authors propose a model checking approach using this
connection between temporal logic and automata theory. They propose the
construction of a finite state, infinite word generator representing the
program $P$, and an acceptor of the same, $\phi$, constructed from the temporal
property to be checked. Thus the program may be model checked by determining
whether $P \cap \lnot \phi$ is empty.

\section{B\"uchi Automata}

Like all $\omega$-automata, the language of a B\"uchi automaton is
$\omega$-regular, i.e. a regular language extended to infinite streams. A
regular language over the alphabet $\Sigma$ is

\begin{itemize}
    \item The empty language $\empty$, \emph{or}
    \item A singleton language $\{a\}$ for $a \in \Sigma$, \emph{or}
    \item For two regular languages $A$ and $B$:
    \begin{itemize}
        \item $A \cup B$ the union of those languages, \emph{or}
        \item $A \centerdot B$ the concatenation of those languages, \emph{or}
        \item $A*$ the Kleene operation on that language.
    \end{itemize}
\end{itemize}

The automata itself is defined as a tuple $A = (Q, \Sigma, \delta, q_0, F)$ where

\begin{itemize} 
    \item $Q$ is a finite set of states,
    \item $\Sigma$ is a finite alphabet,
    \item $\delta : Q \times \Sigma \to Q$ is a transition function mapping states and letters to next states,
    \item $q_0 \in Q$ is an initial state, and
    \item $F \subseteq Q$ is a set of accepting states. 
\end{itemize}

$A$ accepts an input stream iff it visits $F$ infinitely often.

\section{Reactive Synthesis}

\subsection{Synthesis as a Game}

\subsection{GR(1) Games}

\section{Binary Decision Diagrams}

\section{Abstraction}

\section{SAT}

The ability to prove existentially quantified boolean formulas satisfiable or
unsatisfiable (SAT) is enormously useful for program verification. Significant
research has led to many highly efficient solvers for the SAT problem. Modern
SAT solvers are based on the Davis-Putnam-Logemann-Loveland (DPLL) algorithm
\cite{Davis60, Davis62}. This algorithm is a backtracking search that operates
on the formula given in conjunctive normal form (CNF).

A CNF formula is a set of \emph{clauses} of the form $(l_0 \lor l_1 \lor ...
\lor l_n)$ where each \emph{literal} $l_i$ is a boolean variable or its
negation. We call a clause with only one literal a \emph{unit clause}. We call
a variable \emph{pure} if it appears in only one polarity in the formula.

\section{Interpolation}
