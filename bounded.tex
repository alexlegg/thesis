\chapter{Bounded Realisability}
\label{ch:bounded}

\newtheorem*{exmp}{Example}
\newtheorem*{exmpI}{Example: Intuition behind the algorithm}

In this chapter I will describe my work on bounded realisability of reactive systems with safety properties. As introduced in Chapter~\ref{ch:background} reactive realisability is the problem of determining the existence of a program, which we call a \emph{controller}, that continuously interacts with its environment in adherence with a specification. A safety property is a simple correctness condition that lays out a set of states of the system that controller must stay within. In this chapter we will refer to this property in the negation: the controller must avoid \emph{error states}.

Realisability is the first step on the path to synthesis. In the subsequent chapter I will describe an algorithm that extracts the actions of the controller necessary for realisation. This strategy may be used for synthesis: automatic construction of the controller program. Reactive synthesis for controllers with safety properties has many practical uses in areas such as circuit design, device drivers, or industrial automation.

The algorithm described in this chapter solves bounded safety games. Recall that Chapter~\ref{ch:background} introduced games as a formalism for synthesis. In this chapter we are concerned with \emph{bounded} games that restrict all runs to certain length. This concept is borrowed from model checking where it is used for similar aims. Specifically, runs of a bounded game can be checked by a purely propositional formula passed to a SAT solver. The SAT solver provides an efficient method for quickly discovering counterexamples. The algorithm presented here is a counterexample guided abstraction refinement framework that relies on counterexamples to find and refine player strategies.

The primary motivation of this work is to avoid computing the entire set of winning states as would be done in the standard controllable predecessor driven fixpoint algorithm. An explicit representation of the winning set would quickly run into the state explosion issues of synthesis so traditionally the set is represented symbolically with a binary decision diagram. However, a BDD is a canonical representation of a set that, in the worst case, may be exponential in the number of variables. For some systems there is no compact representation of the winning set and for those cases an algorithm that does not compute it, such as the one presented here, is desirable.

\section{Inspiration}


\section{Example}

\begin{exmp}

We introduce a running example to assist the explanation. We consider a simple
arbiter system in which the environment makes a request for a number of
resources (1 or 2), and the controller may grant access to up to two resources.
The total number of requests grows each round by the number of environment
requests and shrinks by the number of resources granted by the controller in
the previous round.  The controller must ensure that the number of unhandled
requests does not accumulate to more than 2.  Figure~\ref{fig:example} shows
the variables (\ref{fig:examplevars}), the initial state of the system (\ref{fig:exampleinit}), 
and the formulas for computing next-state
variable assignments (\ref{fig:exampletrans}) for this example. We use primed identifiers
to denote next-state variables and curly braces to define the domain of a
variable.

This example is the $n=2$ instance of the more general problem of an arbiter of
$n$ resources. For large values of $n$, the set of winning states has no compact representation, which
makes the problem hard for BDD solvers. In Section~3 we will outline how the
unbounded game can be solved without enumerating all winning states.

\end{exmp}

\begin{figure}
    \begin{subfigure}[t]{\textwidth}
        \centering
        \begin{tabular}{l | l | l}
            \textbf{Controllable} & \textbf{Uncontrollable} & \textbf{State} \\
            \hline
            \texttt{request : \{1, 2\}} & \texttt{grant0 = \{0, 1\}} & \texttt{resource0 = \{0, 1\}} \\
            & \texttt{grant1 : \{0, 1\}} & \texttt{resource1 = \{0, 1\}} \\
            & & \texttt{nrequests : \{0, 1, 2, 3\}} \\
        \end{tabular}
        \caption{Variables}
        \label{fig:examplevars}
    \end{subfigure}

    \begin{subfigure}[t]{\textwidth}
        \centering
        \texttt{resource0 = 0; resource1 = 0; nrequests = 0;}
        \caption{Initial State}
        \label{fig:exampleinit}
    \end{subfigure}

    \begin{subfigure}[t]{\textwidth}
        \begin {align*}
            \texttt{resource0'} & \texttt{ = grant0;} \\
            \texttt{resource1'} & \texttt{ = grant1;} \\
            \texttt{nrequests'} & \texttt{ = (nrequests + request >= resource0 + resource1)} \\ 
                                & \texttt{ ? (nrequests + request - resource0 - resource1) : 0;}
        \end{align*}
        \caption{Transition Relation}
        \label{fig:exampletrans}
    \end{subfigure}
    \caption{Example}
    \label{fig:example}
\end{figure}

Our bounded synthesis algorithm constructs abstractions of the game 
that restrict actions available to one of the players.
Specifically, we consider abstractions represented as trees of actions,
referred to as \emph{abstract game trees} (AGTs).  Figure~\ref{fig:agt} shows
an example abstract game tree restricting the environment (abstract game trees
restricting the controller are similar).  In the abstract game, the controller
can freely choose actions whilst the environment is required to pick actions
from the tree.  After reaching a leaf, the environment continues playing
unrestricted.  The tree in Figure~\ref{fig:agt} restricts the first environment
action to \texttt{request=1}. At the leaf of the tree the game continues
unrestricted.

The root of the tree is annotated by the initial state $s$ of the abstract game
and the bound $k$ on the number of rounds.  We denote $\textsc{nodes}(T)$ the
set of all nodes of a tree $T$, $\textsc{leaves}(T)$ the subset of leaf nodes.
For edge $e$, $\textsc{action}(e)$ is the action that labels the edge, and for
node $n$, $\textsc{height}(k, n)$ is the distance from n to the last round of a
game bounded to $k$ rounds.  $\textsc{height}(k, T)$ is the height of the root
node of the tree.  For node $n$ of the tree, $\textsc{succ}(n)$ is the set of
pairs $\langle e, n' \rangle$ where $n'$ is a child node of $n$ and $e$ is the
edge connecting $n$ and $n'$.

\tikzset{every node/.style={solid}}
\tikzstyle{fixed}=[solid]
\begin{figure}
    \centering
    \captionsetup[subfigure]{width=\textwidth,justification=raggedleft}
    \begin{subfigure}[t]{.2\textwidth}
        \centering
        \begin{minipage}[t][3.8cm][t]{\textwidth}
        \begin{tikzpicture}[level distance = 5mm,baseline]
            \node [circle,draw,inner sep=1pt] (root){}
                child {node [circle,draw,inner sep=1pt] {}
                    child {node [circle,draw,inner sep=1pt] {}
                        child {node [circle,draw,inner sep=1pt] {}
                            child {node [circle,draw,inner sep=1pt] {}
                                child {node [circle,draw,inner sep=1pt] {}
                                    node [left=4pt] {\texttt{gr0=0 gr1=0}}
                                }
                                node [left=4pt] {\texttt{req=1}}
                            }
                            node [left=4pt] {\texttt{gr0=0 gr1=0}}
                        }
                        node [left=4pt] {\texttt{req=1}}
                    }
                node [left=4pt] {\texttt{gr0=1 gr1=0}}
                }
                node [left=4pt] {\texttt{req=1}}
                node [above=4pt] {$\langle s, 3 \rangle$};
        \end{tikzpicture}
    \end{minipage}
        \caption{Controller winning trace}
        \label{fig:trace}
    \end{subfigure}
    \begin{subfigure}[t]{.2\textwidth}
        \centering
        \begin{minipage}[t][3.8cm][t]{\textwidth}
        \begin{tikzpicture}[dash pattern = on 2pt off 2pt, level distance = 10mm,baseline]
            \node [circle,draw] (root){}
                child {node [circle,draw] {}
                    edge from parent [fixed] node [left] {\texttt{gr0=1 gr1=0}}
                }
                node [left=4pt] {}
                node [above=4pt] {$\langle s, 3 \rangle$};
        \end{tikzpicture}
        \end{minipage}
        \caption{AGT}
        \label{fig:agt}
    \end{subfigure}
    \begin{subfigure}[t]{.2\textwidth}
        \centering
        \begin{minipage}[t][3.8cm][t]{\textwidth}
        \begin{tikzpicture}[level distance = 5mm,baseline]
            \node [circle,draw,inner sep=1pt] (root){}
                child {node [circle,draw,inner sep=1pt] {}
                    child {node [circle,draw,inner sep=1pt] {}
                        child {node [circle,draw,inner sep=1pt] {}
                            child {node [circle,draw,inner sep=1pt] {}
                                child {node [circle,draw,inner sep=1pt] {}
                                    node [left=4pt] {\texttt{gr0=0 gr1=0}}
                                }
                                node [left=4pt] {\texttt{req=1}}
                            }
                            node [left=4pt] {\texttt{gr0=0 gr1=0}}
                        }
                        node [left=4pt] {\texttt{req=1}}
                    }
                node [left=4pt] {\texttt{gr0=1 gr1=0}}
                }
                node [left=4pt] {\texttt{req=2}}
                node [above=4pt] {$\langle s, 3 \rangle$};
        \end{tikzpicture}
        \end{minipage}
        \caption{Environment winning trace}
        \label{fig:trace2}
    \end{subfigure}
    \begin{subfigure}[t]{.2\textwidth}
        \centering
        \begin{minipage}[t][3.8cm][t]{\textwidth}
        \begin{tikzpicture}[dash pattern = on 2pt off 2pt, level distance = 10mm,baseline]
            \node [circle,draw] (root){}
                child {node [circle,draw] {}
                    edge from parent [fixed] node [left] {\texttt{gr0=1 gr1=0}}
                }
                node [left=4pt] {\texttt{req=2}}
                node [above=4pt] {$\langle s, 3 \rangle$};
        \end{tikzpicture}
        \end{minipage}
        \caption{Partial Strategy}
        \label{fig:strategy}
    \end{subfigure}
    \caption{Abstract game trees.}
    \label{fig:alltrees}
\end{figure}


Given an environment (controller) abstract game tree $T$ a \emph{partial
strategy} $Strat: \textsc{nodes}(T) \rightarrow \mathcal{C}$ ($Strat: \textsc{nodes}(T)
\rightarrow \mathcal{U}$) labels each node of the tree with the controller's
(environment's) action to be played in that node.   Given a partial strategy
$Strat$, we can map each leaf $l$ of the abstract game tree to $\langle
s',i'\rangle=\textsc{outcome}(\langle s, i\rangle, Strat, l)$ obtained by
playing all controllable and uncontrollable actions on the path from the root
to the leaf.  An environment (controller) partial strategy is \emph{winning against $T$} 
if all its outcomes are states that are winning for the environment (controller)
in the concrete game.


%%%Figure~\ref{fig:strategy} shows an example partial strategy for
%%%the controller.  The controller responds to the requests by first granting
%%%access to \texttt{resource1}, then to \texttt{resource0} in the second round.

\begin{exmpI}

    %% Make it clear that this is intuition only
    We present the intuition behind our bounded synthesis method by applying
    its \emph{simplified version} to the running example.  We begin by finding
    a trace of length $k$ (here we consider $k=3$) that is winning for the
    controller, i.e., that starts from the initial state and avoids the error
    set for three game rounds (see Figure~\ref{fig:trace}).  We use a SAT
    solver to find such a trace, precisely as one would do in bounded model
    checking.  Given this trace we make an initial conjecture that any trace
    starting with action \texttt{gr0=1 gr1=0} is winning for the controller.
    This conjecture is captured in the abstract game tree shown in
    Figure~\ref{fig:agt}.  We validate this conjecture by searching for a
    counterexample trace that reaches an error state with the first controller
    action fixed to \texttt{gr0=1 gr1=0}.   Such a trace, that refutes the
    conjecture, is shown in Figure~\ref{fig:trace2}.  In this trace, the
    environment wins by playing \texttt{req=2} in the first round.  This move
    represents the environment's partial strategy against the abstract game
    tree in Figure~\ref{fig:agt}.  This partial strategy is shown in
    Figure~\ref{fig:strategy}.
    
    Next we strengthen the abstract game tree taking this partial strategy into account.
    To this end we again use a SAT solver to find a trace where the contoller
    wins while the environment plays according to the partial strategy.  In the
    resulting trace (Figure~\ref{fig:trace3}), the controller plays \texttt{gr0=1 gr1=1} in
    the second round.  We refine the abstract game tree using this move as
    shown in Figure~\ref{fig:refined1}.  The environment's partial strategy was
    to make two requests in the first round, to which the controller responds
    by now granting an additional two resources in the second round.

    When the controller cannot refine the tree by extending existing branches,
    it backtracks and creates new branches. Eventually, we obtain the abstract
    game tree shown in Figure~\ref{fig:refined2} for which there does not exist
    a winning partial strategy on behalf of the environment.  We conclude that
    the bounded game is winning for the controller.

\end{exmpI}

\begin{figure}
    \centering
    \begin{subfigure}[t]{.2\textwidth}
        \centering
        \begin{minipage}[t][3.8cm][t]{\textwidth}
        \begin{tikzpicture}[level distance = 5mm,baseline]
            \node [circle,draw,inner sep=1pt] (root){}
                child {node [circle,draw,inner sep=1pt] {}
                    child {node [circle,draw,inner sep=1pt] {}
                        child {node [circle,draw,inner sep=1pt] {}
                            child {node [circle,draw,inner sep=1pt] {}
                                child {node [circle,draw,inner sep=1pt] {}
                                    node [left=4pt] {\texttt{gr0=0 gr1=0}}
                                }
                                node [left=4pt] {\texttt{req=1}}
                            }
                            node [left=4pt] {\texttt{gr0=1 gr1=1}}
                        }
                        node [left=4pt] {\texttt{req=1}}
                    }
                node [left=4pt] {\texttt{gr0=1 gr1=0}}
                }
                node [left=4pt] {\texttt{req=2}}
                node [above=4pt] {$\langle s, 3 \rangle$};
        \end{tikzpicture}
        \end{minipage}
        \caption{Controller winning trace}
        \label{fig:trace3}
    \end{subfigure}
    \begin{subfigure}[t]{.3\textwidth}
        \centering
        \begin{minipage}[t][3.8cm][t]{\textwidth}
        \hspace*{0.8cm}
        \begin{tikzpicture}[dash pattern = on 2pt off 2pt, level distance = 10mm,baseline]
            \node [circle,draw] (root){}
                child {node [circle,draw] {}
                    child {node [circle,draw] {}
                        edge from parent [fixed] node [left] {\texttt{gr0=1 gr1=1}}
                    }
                    edge from parent [fixed] node [left] {\texttt{gr0=1 gr1=0}}
                }
                node [above=4pt] {$\langle s, 3 \rangle$};
        \end{tikzpicture}
        \end{minipage}
        \caption{First refined AGT}
        \label{fig:refined1}
    \end{subfigure}
    \begin{subfigure}[t]{.4\textwidth}
        \centering
        \begin{minipage}[t][3.8cm][t]{\textwidth}
        \begin{tikzpicture}[dash pattern = on 2pt off 2pt, level distance = 10mm,baseline]
            \node [circle,draw] (root){}
                child {node [circle,draw] {}
                    child {node [circle,draw] {}
                        child {node [circle,draw] {}
                            edge from parent [fixed] node [left] {\texttt{gr0=1 gr1=1}}
                        }
                        edge from parent [fixed] node [left] {\texttt{gr0=1 gr1=1}}
                    }
                    edge from parent [fixed] node [left] {\texttt{gr0=1 gr1=0}}
                }
                child {node [circle,draw] {}
                    child {node [circle,draw] {}
                        child {node [circle,draw] {}
                            edge from parent [fixed] node [right] {\texttt{gr0=1 gr1=1}}
                        }
                        edge from parent [fixed] node [right] {\texttt{gr0=1 gr1=1}}
                    }
                    edge from parent [fixed] node [right] {\texttt{gr0=1 gr1=1}}
                }
                node [above=4pt] {$\langle s, 3 \rangle$};
        \end{tikzpicture}
        \end{minipage}
        \caption{Final Refined AGT}
        \label{fig:refined2}
    \end{subfigure}
    \caption{Refined abstract game trees.}
    \label{fig:refinedtrees}
\end{figure}


\begin{algorithm}[t]
    \begin{algorithmic}[1]
        \Function{solveAbstract}{$p, s, k, T$}
        \State $cand \gets $ \Call{findCandidate}{$p, s, k, T$} \Comment{Look for a candidate}
        \IIf{$k = 1$} \Return $cand$ \EndIIf \Comment{Reached the bound}
        \State $T' \gets T$
        \Loop
            \IIf{$cand = \texttt{NULL}$} \Return $\texttt{NULL}$ \EndIIf \Comment{No candidate: return with no solution}
            \State $\langle cex, l, u \rangle \gets $ \Call{verify}{$p, s, k, T, cand$} \Comment{Verify candidate}
            \IIf{$cex = \False$} \Return $cand$ \EndIIf \Comment{No counterexample: return candidate}
            \State $T' \gets $ \Call{append}{$T', l, u$} \Comment{Refine $T'$ with counterexample}
            \State $cand \gets $ \Call{solveAbstract}{$p, s, k, T'$} \Comment{Solve refined game tree}
        \EndLoop
        \EndFunction
        \algstore{b1}
    \end{algorithmic}

    \begin{algorithmic}
        \algrestore{b1}
        \Function{findCandidate}{$p, s, k, T$}
        \State $\hat{T} \gets $ \Call{extend}{$T$} \Comment{Extend the tree with unfixed actions}
            \State $f \gets $ \IfElse{$p = \texttt{cont}$}{\Call{treeFormula}{$k, \hat{T}$}}{\Call{\textoverline{treeFormula}}{$k, \hat{T}$}} \EndIfElse
            \State $sol \gets $ \Call{SAT}{$s(X_{\hat{T}}) \land f$}
            \If{$sol = \texttt{unsat}$} 
                \If{\texttt{unbounded}} \Comment{Active only in the unbounded solver}
                    %\State $\sigma \gets $ \Call{generalise}{$s$} \Comment{Expand $s$ to a set of states}
                    \State \IfElse{$p = \texttt{cont}$}{\Call{learn}{$s, \hat{T}$}}{\Call{\textoverline{learn}}{$s, \hat{T}$}} \EndIfElse
                \EndIf
                \State \Return $\texttt{NULL}$ \Comment{No candidate exists}
            \Else
                \State \Return $\{ \langle n, c \rangle | n \in $ \Call{nodes}{$T$} $, c = \Call{sol}{n} \}$ \Comment{Fix candidate moves in $T$}
            \EndIf
        \EndFunction
        \algstore{b2}
    \end{algorithmic}

    \begin{algorithmic}
        \algrestore{b2}
        \Function{verify}{$p, s, k, T, cand$}
            \For{$l \in leaves(gt)$}
            \State $\langle k', s'\rangle \gets $ \Call{outcome}{$s, k, cand, l$} \Comment{Get bound and state at leaf}
                \State $u \gets $ \Call{solveAbstract}{\Call{opponent}{$p$}, $s'$, $k'$, $\emptyset$} \Comment{Solve for the opponent}
                \IIf{$u \neq \texttt{NULL}$} \Return $\langle \True, l, u \rangle$ \EndIIf \Comment{Return counterexample}
            \EndFor
            \State \Return $\langle \False, \emptyset, \emptyset \rangle$
        \EndFunction
    \end{algorithmic}

    \caption{Bounded synthesis}
    \label{alg:bounded}
\end{algorithm}

The full bounded synthesis algorithm is more complicated: upon finding a candidate 
partial strategy on behalf of player $p$ against abstract game tree $T$, it first checks whether the strategy is winning 
against $T$.  By only considering such strong candidates, we reduce the number of 
refinements needed to solve the game.  To this end, the algorithm checks whether each 
outcome of the candidate strategy is a winning state for $\textsc{opponent}(p)$ by recursively 
invoking the synthesis algorithm on behalf of the opponent.  Thus, our bounded
synthesis algorithm can be seen as running two competing solvers, for the
controller and for the environment. 

%The solvers build candidate partial strategy 
%for their corresponding players, which are used to refine the abstractions.


The full procedure is illustrated in Algorithm~\ref{alg:bounded}.  The
algorithm takes a concrete game $G$ with maximum bound $\kappa$ as an implicit
argument.  In addition, it takes a player $p$ (controller or environment),
state $s$, bound $k$ and an abstract game tree $T$ and returns a winning
partial strategy for $p$, if one exists.  The initial invocation of the
algorithm takes the initial state $I$, bound $\kappa$ and an empty abstract
game tree $\emptyset$.  Initially the solver is playing on behalf of the
environment since that player takes the first move in every game round.  The
empty game tree does not constrain opponent moves, hence solving such an
abstraction is equivalent to solving the original concrete game.

The algorithm is organised as a counterexample-guided abstraction refinement
(CEGAR) loop.  The first step of the algorithm uses the \textsc{findCandidate}
function, described below, to come up with a candidate partial strategy that is
winning when the opponent is restricted to $T$.  If it fails to find a
strategy, this means that no winning partial strategy exists against the opponent
playing according to $T$.  If, on the other hand, a
candidate partial strategy is found, we need to verify if it is indeed winning
for the abstract game $T$.

The \textsc{verify} procedure searches for a \emph{spoiling} counterexample
strategy in each leaf of the candidate partial strategy by calling
\textsc{solveAbstract} for the opponent. The dual solver solves games on behalf
of the opponent player.  

If the dual solver can find no spoiling strategy at any of the leaves, then the
candidate partial strategy is a winning one. Otherwise, \textsc{verify} returns
the move used by the opponent to defeat a leaf of the partial strategy, which
is appended to the corresponding node in $T$ in order to refine it in line~(9).

We solve the refined game by recursively invoking \textsc{solveAbstract} on it.
If no partial winning strategy is found for the refined game then there is also
no partial winning strategy for the original abstract game, and the algorithm
returns a failure.  Otherwise, the partial strategy for the refined game is
\emph{projected} on the original abstract game by removing the leaves
introduced by refinements. The resulting partial strategy becomes a candidate
strategy to be verified at the next iteration of the loop. In the worst case
the loop terminates after all actions in the game are refined into the abstract
game.

The CEGAR loop depends on the ability to guess candidate partial strategies in
\textsc{findCandidate}. For this purpose we use the heuristic that a partial
strategy may be winning if each \textsc{outcome} of the strategy can be
extended to a run of the game that is winning for the current player.  Clearly,
if such a partial strategy does not exist then no winning partial strategy can
exist for the abstract game tree. We can formulate this heuristic as a SAT
query, which is constructed recursively by $\textsc{treeFormula}$ (for the
controller) or $\textsc{\textoverline{treeFormula}}$ (for the environment) in
Algorithm~\ref{alg:treeFormula}.

The tree is first extended to the maximum bound with edges that are labeled
with arbitrary opponent actions (Algorithm~\ref{alg:bounded}, line 14).  For
each node in the tree, new SAT variables are introduced corresponding to the
state ($X_T$) and action ($U_T$ or $C_T$) variables of that node. Additional
variables for the opponent actions in the edges of $T$ are introduced ($U_e$ or
$C_e$) and set to $\textsc{action}(e)$.  The state and action variables of node
$n$ are connected to successor nodes $\textsc{succ}(n)$ by an encoding of the
transition relation and constrained to the winning condition of the player.

%%%Then copies of state and action variables are introduced for each node in the
%%%tree and opponent action variables for each edge $e$ are set to
%%%$\textsc{action}(e)$. 

%%%Candidates are discovered by passing a formulation of the abstract game tree to
%%%a SAT solver in $\textsc{findCandidate}$. This formula contains CNF encodings
%%%of all of the unrolled runs represented by the tree and the winning condition
%%%of the current player.  Runs are encoded by copying the transition relation for
%%%every step in the abstract game. When playing for the controller, the SAT
%%%solver searches for a satisfying assignment to the unfixed label variables in
%%%tree so that none of the runs reaches the error state. The environment
%%%formulation is satisfiable if any run does reach the error state.  The formula
%%%is constructed recursively from the root of a tree by $\textsc{treeFormula}$
%%%(see Algorithm~\ref{alg:treeFormula}).

%%%Since the game tree formulation is passed to a SAT solver, both controllable
%%%and uncontrollable unfixed labels will be existentially quantified. This means
%%%that the SAT solver will find any way to win the game while both players are
%%%cooperating. If no winning run exists in an abstract game even when the players
%%%are cooperating then there is no winning run when the opponent is playing
%%%adversarily. When a winning run is found, the actions chosen by the SAT solver
%%%are used to refine the game tree. This is advantageous for many synthesis
%%%problems where the game must be formalised as adversarial for correctness but
%%%the final implementation will cooperate with its environment in the real world.
%%%An example of such a system is a device driver that cooperates with the device
%%%and OS to provide the interface between the two.

\begin{algorithm}
    \caption{Tree formulas for Controller and Environment respectively}
    \label{alg:treeFormula}
    \begin{algorithmic}[1]
        \Function{treeFormula}{$k, T$}
        \If{$\Call{height}{k, T} = 0$}
        \State \Return{ $\lnot \Call{E}{X_{T}}$ }
        \Else
        \State \Return{$\lnot \Call{E}{X_{T}} \land$ \\
            $$\bigwedge_{\langle e, n \rangle \in \Call{succ}{T}}(\Call{$\delta$}{X_T, U_e, C_T, X_n} \land U_e = \Call{action}{e} \land \Call{treeFormula}{k, n})$$
        }
        \EndIf
        \EndFunction
        \algstore{tf1}
    \end{algorithmic}

    \begin{algorithmic}[1]
        \algrestore{tf1}
        \Function{\textoverline{treeFormula}}{$k, T$}
        \If{$\Call{height}{k, T} = 0$}
        \State \Return{\Call{E}{$X_{T}$}}
        \Else
        \State \Return{ $\Call{E}{X_{T}} \lor$ \\
        $$\bigvee_{\langle e, n \rangle \in \Call{succ}{T}}(\Call{$\delta$}{X_T, U_T, C_e, X_n} \land C_e = \Call{action}{e} \land \Call{\textoverline{treeFormula}}{k, n})$$ }
        \EndIf
        \EndFunction
    \end{algorithmic}
\end{algorithm}
