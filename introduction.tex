\chapter{Introduction}

Since the explosion of computers into the modern world we have learned several important facts about the software systems that now surround us. First, that they are incredibly useful and we can now barely live without them. Second, when software is poorly written the cost in money, time, and even lives can be catastrophic. And lastly, it is very difficult to write software well.

The dream of having our software automatically constructed for us, first formally considered by Alonzo Church in the middle of the last century~\cite{Church62}, has the potential to solve these problems by taking software out of the hands of humans. 

\section{Device Drivers}

Device drivers are the software that allows the operating system to interface
with hardware. The role of the driver is to manipulate the inputs of the device
so that it remains in a error-free state and correctly handles the requests of
the operating system. By way of example consider an ethernet driver. The driver
accepts requests to send and receive data packets from the OS and acts on those
requests by reading from and writing to buffers on the device. It must ensure
that those buffers are maintained in a usable state by correctly updating a
register containing the location of the head of the buffer queue.

According to a study performed in 2011~\cite{Palix11}, drivers account for
approximately 57\% of the lines of code in the Linux kernel and subsequently is
the largest source of bugs. The study also analysed the staging directory of
the kernel, which contains all in-progress drivers, and found it to contain the
highest fault rate (faults per line of code) out of any directory in the
kernel. The results of the study give evidence to the widely held belief that
correct drivers are hard to produce.

Consequences of buggy drivers

This thesis focuses on automatic construction of correct drivers as a solution
to the driver problem. Alternate approaches, of which there are many, will be
discussed in Chapter~\ref{ch:relatedwork}.

\section{Synthesis}

Explain what synthesis is

Briefly describe the current state of the art

Explain state space explosion

\section{Synthesis with SAT}

Explain SAT solvers

Explain how they might help with state space explosion

(Explain that there is room for both approaches in the world)

Explain QBF and/or why this is nontrivial
