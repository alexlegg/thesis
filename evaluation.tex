\chapter{Evaluation}
\label{ch:evaluation}

\newcommand{\eva}[0]{\textsc{EvaSolver}\xspace}

In this chapter I present benchmarking results for the implementations of each previous chapter. Bounded realisability is implemented in a tool called \eva as joint work between Nina Narodytska and myself. \eva was built in C++ and is based on the source code of RAReQS~\cite{Janota12}. The tool calls out to Glucose~\cite{Audemard09} for SAT solving. Strategy extraction was later added to \eva using PeRIPLO~\cite{Rollini13} to construct interpolants. The implementation also uses cudd~\cite{Somenzi01} to reduce interpolants into cubes via BDDs. I implemented unbounded realisability in a separate open source tool, TermiteSAT~\cite{TermiteSAT}, which contains a reimplementation of the bounded realisability algorithm. TermiteSAT is written in Haskell and also uses Glucose for SAT solving, PeRIPLO for interpolant construction, and cudd to reduce interpolants to cubes. TermiteSAT was submitted to the 2016 synthesis competition and the results are shown below. As part of that submission I added a hybrid mode to TermiteSAT that runs the unbounded synthesis algorithm in parallel with Simple BDD Solver~\cite{Walker14b}.

\section{Bounded realisability}

The algorithm is evaluated on four families of benchmarks derived from driver synthesis problems.  These benchmarks model the data path of four I/O devices in the abstracted form.  In particular, we model the transmit buffer of an Ethernet adapter, the send queue of a UART serial controller, the command queue of an SPI Flash controller, and the IDE hard disk DMA descriptor list.   Models are parameterised by the size of the corresponding data structure.  Specifications are written in a simple input language based on the NuSMV syntax~\cite{Henzinger03}.   The transition relation of the game is given in the form of variable update functions $s' := f(\mathcal{S}, \mathcal{U}, \mathcal{C})$, one for each state variable $s \in \mathcal{S}$.

We compare our solver against two existing approaches to solving games.  First, we encode input specifications as QBF instances and solve them using two state-of-the-art QBF solvers: RAReQS~\cite{Janota12} and depqbf~\cite{Lonsing10}, having first run them through the bloqqer~\cite{Biere11} preprocessor.  Second, we solve our benchmarks using the Termite~\cite{Walker14} BDD-based solver that uses dynamic variable reordering, variable grouping, transition relation partitioning, and other optimisations. 

Our experiments, summarised in \Cref{fig:uart,fig:ide,fig:spi,fig:ethernet}, show that off-the-shelf QBF solvers are not well-suited for solving games.  Although our algorithm is inspired by RAReQS, we achieve much better performance, since our solver takes into account the structure of the game, rather than treating it as a generic QBF problem.  

\begin{figure}
    \centering
    \begin{tikzpicture}[y=0.002cm, x=0.2cm]
        %axis
        \draw (0,0) -- coordinate (x axis mid) (50,0);
            \draw (0,0) -- coordinate (y axis mid) (0,4000);
            %ticks
            \foreach \x in {0,5,...,50}
                \draw (\x,1pt) -- (\x,-3pt)
                node[anchor=north] {\x};
            \foreach \y in {0,500,...,4000}
                \draw (1pt,\y) -- (-3pt,\y) 
                    node[anchor=east] {\y}; 
        %labels      
        \node[below=0.8cm] at (x axis mid) {Instance size ($| \mathcal{S} |$)};
        \node[rotate=90, above left=1cm and 1.5cm] at (y axis mid) {Time (seconds)};
        
        %Plots
        \draw plot[mark=o, mark size=2pt, mark options={fill=white,color=red}] file {data/bench_uart_eva.dat};
        \draw plot[mark=+, mark options={fill=white,color=blue}] file {data/bench_uart_termite.dat};
        \draw plot[mark=triangle, mark size=2pt, mark options={fill=white}] file {data/bench_uart_depqbf.dat};
        \draw plot[mark=x, mark options={fill=white,color=green}] file {data/bench_uart_rareqs.dat};

        \begin{scope}[shift={(5,2000)}] 
            \draw (0,0) -- 
                plot[mark=o, mark size=2pt, mark options={fill=white,color=red}] (0.25,0)
                node[right]{Bounded realisability};
            \draw[yshift=\baselineskip] (0,0) -- 
                plot[mark=x, mark options={fill=white,color=green}] (0.25,0)
                node[right]{Rareqs};
            \draw[yshift=2\baselineskip] (0,0) -- 
                plot[mark=+, mark options={fill=white,color=blue}] (0.25,0)
                node[right]{Termite};
            \draw[yshift=3\baselineskip] (0,0) -- 
                plot[mark=triangle, mark options={fill=white}] (0.25,0)
                node[right]{DepQBF};
        \end{scope}

    \end{tikzpicture}
    \caption{UART}
    \label{fig:uart}
\end{figure}

\begin{figure}
    \centering
    \begin{tikzpicture}[y=0.002cm, x=0.2cm]
        %axis
        \draw (0,0) -- coordinate (x axis mid) (50,0);
            \draw (0,0) -- coordinate (y axis mid) (0,2000);
            %ticks
            \foreach \x in {0,5,...,50}
                \draw (\x,1pt) -- (\x,-3pt)
                node[anchor=north] {\x};
            \foreach \y in {0,500,...,2000}
                \draw (1pt,\y) -- (-3pt,\y) 
                    node[anchor=east] {\y}; 
        %labels      
        \node[below=0.8cm] at (x axis mid) {Instance size ($| \mathcal{S} |$)};
        \node[rotate=90, above left=1cm and 1.5cm] at (y axis mid) {Time (seconds)};
        
        %Plots
        \draw plot[mark=o, mark size=2pt, mark options={fill=white,color=red}] file {data/bench_ide_eva.dat};
        \draw plot[mark=+, mark options={fill=white,color=blue}] file {data/bench_ide_termite.dat};

        \begin{scope}[shift={(5,500)}] 
            \draw (0,0) -- 
                plot[mark=o, mark size=2pt, mark options={fill=white,color=red}] (0.25,0)
                node[right]{Bounded realisability};
            \draw[yshift=\baselineskip] (0,0) -- 
                plot[mark=x, mark options={fill=white,color=green}] (0.25,0)
                node[right]{Rareqs};
            \draw[yshift=2\baselineskip] (0,0) -- 
                plot[mark=+, mark options={fill=white,color=blue}] (0.25,0)
                node[right]{Termite};
            \draw[yshift=3\baselineskip] (0,0) -- 
                plot[mark=triangle, mark options={fill=white}] (0.25,0)
                node[right]{DepQBF};
        \end{scope}

    \end{tikzpicture}
    \caption{IDE DMA}
    \label{fig:ide}
\end{figure}

\begin{figure}
    \centering
    \begin{tikzpicture}[y=0.002cm, x=0.1cm]
        %axis
        \draw (0,0) -- coordinate (x axis mid) (100,0);
            \draw (0,0) -- coordinate (y axis mid) (0,3000);
            %ticks
            \foreach \x in {0,20,...,100}
                \draw (\x,1pt) -- (\x,-3pt)
                node[anchor=north] {\x};
            \foreach \y in {0,500,...,3000}
                \draw (1pt,\y) -- (-3pt,\y) 
                    node[anchor=east] {\y}; 
        %labels      
        \node[below=0.8cm] at (x axis mid) {Instance size ($| \mathcal{S} |$)};
        \node[rotate=90, above left=1cm and 1.5cm] at (y axis mid) {Time (seconds)};
        
        %Plots
        \draw plot[mark=o, mark size=2pt, mark options={fill=white,color=red}] file {data/bench_spi_eva.dat};
        \draw plot[mark=+, mark options={fill=white,color=blue}] file {data/bench_spi_termite.dat};
        \draw plot[mark=triangle, mark size=2pt, mark options={fill=white}] file {data/bench_spi_depqbf.dat};
        \draw plot[mark=x, mark options={fill=white,color=green}] file {data/bench_spi_rareqs.dat};

        \begin{scope}[shift={(5,2000)}] 
            \draw (0,0) -- 
                plot[mark=o, mark size=2pt, mark options={fill=white,color=red}] (0.25,0)
                node[right]{Bounded realisability};
            \draw[yshift=\baselineskip] (0,0) -- 
                plot[mark=x, mark options={fill=white,color=green}] (0.25,0)
                node[right]{Rareqs};
            \draw[yshift=2\baselineskip] (0,0) -- 
                plot[mark=+, mark options={fill=white,color=blue}] (0.25,0)
                node[right]{Termite};
            \draw[yshift=3\baselineskip] (0,0) -- 
                plot[mark=triangle, mark options={fill=white}] (0.25,0)
                node[right]{DepQBF};
        \end{scope}

    \end{tikzpicture}
    \caption{SPI}
    \label{fig:spi}
\end{figure}

\begin{figure}
    \centering
    \begin{tikzpicture}[y=0.002cm, x=0.15cm]
        %axis
        \draw (0,0) -- coordinate (x axis mid) (70,0);
            \draw (0,0) -- coordinate (y axis mid) (0,4000);
            %ticks
            \foreach \x in {0,5,...,70}
                \draw (\x,1pt) -- (\x,-3pt)
                node[anchor=north] {\x};
            \foreach \y in {0,500,...,4000}
                \draw (1pt,\y) -- (-3pt,\y) 
                    node[anchor=east] {\y}; 
        %labels      
        \node[below=0.8cm] at (x axis mid) {Instance size ($| \mathcal{S} |$)};
        \node[rotate=90, above left=1cm and 1.5cm] at (y axis mid) {Time (seconds)};
        
        %Plots
        \draw plot[mark=o, mark size=2pt, mark options={fill=white,color=red}] file {data/bench_queue_eva.dat};
        \draw plot[mark=+, mark options={fill=white,color=blue}] file {data/bench_queue_termite.dat};
        \draw plot[mark=triangle, mark size=2pt, mark options={fill=white}] file {data/bench_queue_depqbf.dat};
        \draw plot[mark=x, mark options={fill=white,color=green}] file {data/bench_queue_rareqs.dat};

        \begin{scope}[shift={(5,2000)}] 
            \draw (0,0) -- 
                plot[mark=o, mark size=2pt, mark options={fill=white,color=red}] (0.25,0)
                node[right]{Bounded realisability};
            \draw[yshift=\baselineskip] (0,0) -- 
                plot[mark=x, mark options={fill=white,color=green}] (0.25,0)
                node[right]{Rareqs};
            \draw[yshift=2\baselineskip] (0,0) -- 
                plot[mark=+, mark options={fill=white,color=blue}] (0.25,0)
                node[right]{Termite};
            \draw[yshift=3\baselineskip] (0,0) -- 
                plot[mark=triangle, mark options={fill=white}] (0.25,0)
                node[right]{DepQBF};
        \end{scope}

    \end{tikzpicture}
    \caption{Ethernet}
    \label{fig:ethernet}
\end{figure}

All four benchmarks have very large sets of winning states.  
Nevertheless, in the UART and IDE benchmarks, Termite is able to 
represent winning states compactly with only a few thousand BDD 
nodes.  It scales well and outperforms \eva on these benchmarks.  
However, in the two other benchmarks, Termite does not find a 
compact BDD-based representation of the winning set.  \eva 
outperforms Termite on these benchmarks as it does not try to 
enumerate all winning states.

{Detailed performance analysis shows that 
abstract game trees generated in our benchmarks had average 
branching factors in the range between $1.03$ and $1.2$, with 
the maximal depth of the trees ranging from $3$ to $58$.  This
confirms the the key premise behind the design of \eva, namely, 
solving real-world synthesis problems requires considering only a 
small number of opponent moves in every state of the game.}  

\section{Strategy extraction}

%%%\eva implements an important optimisation whereby it generates multiple certificate trees for fragments of the original game, which enables computational learning of winning states.  Our strategy generation algorithm is invoked in an online fashion, whenever \eva computes a certificate tree for a fragment.  This results in multiple partial strategies, where each strategy is computed as described in the previous section.  We introduce an additional final step to \eva, which combines partial strategies into a global winning strategy for the original game.

Strategy extraction is evaluated on the same set of driver synthesis benchmarks.  \Cref{fig:uart2,fig:ide2,fig:spi2,fig:ethernet2} sumarise the results.  For each family, we show strategy generation time as a function of the number of state variables in the specification for $5$ hardest instances of the family solved by \eva.  Specifically, we show the time it took the base solver to determine the winner (the realisability line), as well as the total time taken to solve the game and compute the winning strategy (the total line).

Profiling showed that non-negligible overhead was introduced by
transferring CNFs from $\eva$'s internal representation to the
representation used by the interpolation library.  This overhead
can be almost completely eliminated with additional engineering
effort.
%in translating CNFs from $\eva$ representation to the
%interpolants library which can be avoided by careful reuse of
%PeRIPLO as CNF formulas share a lot of clauses.
Hence, we also show the effective time spent solving the game and
computing the strategy, excluding the formula translation time
(the Effective Time line).

\begin{figure}
    \centering
    \begin{tikzpicture}[y=0.002cm, x=0.2cm]
        %axis
        \draw (0,0) -- coordinate (x axis mid) (50,0);
            \draw (0,0) -- coordinate (y axis mid) (0,4000);
            %ticks
            \foreach \x in {0,5,...,50}
                \draw (\x,1pt) -- (\x,-3pt)
                node[anchor=north] {\x};
            \foreach \y in {0,500,...,4000}
                \draw (1pt,\y) -- (-3pt,\y) 
                    node[anchor=east] {\y}; 
        %labels      
        \node[below=0.8cm] at (x axis mid) {Instance size ($| \mathcal{S} |$)};
        \node[rotate=90, above left=1cm and 1.5cm] at (y axis mid) {Time (seconds)};
        
        %Plots
        \draw plot[mark=o, mark size=2pt, mark options={fill=white,color=red}] file {data/bench_strat_uart_total.dat};
        \draw plot[mark=+, mark options={fill=white,color=blue}] file {data/bench_strat_uart_real.dat};

        \begin{scope}[shift={(5,2000)}] 
            \draw (0,0) -- 
                plot[mark=o, mark size=2pt, mark options={fill=white,color=red}] (0.25,0)
                node[right]{Bounded realisability};
            \draw[yshift=\baselineskip] (0,0) -- 
                plot[mark=x, mark options={fill=white,color=green}] (0.25,0)
                node[right]{Rareqs};
            \draw[yshift=2\baselineskip] (0,0) -- 
                plot[mark=+, mark options={fill=white,color=blue}] (0.25,0)
                node[right]{Termite};
            \draw[yshift=3\baselineskip] (0,0) -- 
                plot[mark=triangle, mark options={fill=white}] (0.25,0)
                node[right]{DepQBF};
        \end{scope}

    \end{tikzpicture}
    \caption{UART}
    \label{fig:uart2}
\end{figure}

\begin{figure}
    \centering
    \begin{tikzpicture}[y=0.002cm, x=0.2cm]
        %axis
        \draw (0,0) -- coordinate (x axis mid) (50,0);
            \draw (0,0) -- coordinate (y axis mid) (0,4000);
            %ticks
            \foreach \x in {0,5,...,50}
                \draw (\x,1pt) -- (\x,-3pt)
                node[anchor=north] {\x};
            \foreach \y in {0,500,...,4000}
                \draw (1pt,\y) -- (-3pt,\y) 
                    node[anchor=east] {\y}; 
        %labels      
        \node[below=0.8cm] at (x axis mid) {Instance size ($| \mathcal{S} |$)};
        \node[rotate=90, above left=1cm and 1.5cm] at (y axis mid) {Time (seconds)};
        
        %Plots
        \draw plot[mark=o, mark size=2pt, mark options={fill=white,color=red}] file {data/bench_strat_ide_total.dat};
        \draw plot[mark=+, mark options={fill=white,color=blue}] file {data/bench_strat_ide_real.dat};

        \begin{scope}[shift={(5,2000)}] 
            \draw (0,0) -- 
                plot[mark=o, mark size=2pt, mark options={fill=white,color=red}] (0.25,0)
                node[right]{Bounded realisability};
            \draw[yshift=\baselineskip] (0,0) -- 
                plot[mark=x, mark options={fill=white,color=green}] (0.25,0)
                node[right]{Rareqs};
            \draw[yshift=2\baselineskip] (0,0) -- 
                plot[mark=+, mark options={fill=white,color=blue}] (0.25,0)
                node[right]{Termite};
            \draw[yshift=3\baselineskip] (0,0) -- 
                plot[mark=triangle, mark options={fill=white}] (0.25,0)
                node[right]{DepQBF};
        \end{scope}

    \end{tikzpicture}
    \caption{ide}
    \label{fig:ide2}
\end{figure}

\begin{figure}
    \centering
    \begin{tikzpicture}[y=0.002cm, x=0.2cm]
        %axis
        \draw (0,0) -- coordinate (x axis mid) (50,0);
            \draw (0,0) -- coordinate (y axis mid) (0,4000);
            %ticks
            \foreach \x in {0,5,...,50}
                \draw (\x,1pt) -- (\x,-3pt)
                node[anchor=north] {\x};
            \foreach \y in {0,500,...,4000}
                \draw (1pt,\y) -- (-3pt,\y) 
                    node[anchor=east] {\y}; 
        %labels      
        \node[below=0.8cm] at (x axis mid) {Instance size ($| \mathcal{S} |$)};
        \node[rotate=90, above left=1cm and 1.5cm] at (y axis mid) {Time (seconds)};
        
        %Plots
        \draw plot[mark=o, mark size=2pt, mark options={fill=white,color=red}] file {data/bench_strat_spi_total.dat};
        \draw plot[mark=+, mark options={fill=white,color=blue}] file {data/bench_strat_spi_real.dat};

        \begin{scope}[shift={(5,2000)}] 
            \draw (0,0) -- 
                plot[mark=o, mark size=2pt, mark options={fill=white,color=red}] (0.25,0)
                node[right]{Bounded realisability};
            \draw[yshift=\baselineskip] (0,0) -- 
                plot[mark=x, mark options={fill=white,color=green}] (0.25,0)
                node[right]{Rareqs};
            \draw[yshift=2\baselineskip] (0,0) -- 
                plot[mark=+, mark options={fill=white,color=blue}] (0.25,0)
                node[right]{Termite};
            \draw[yshift=3\baselineskip] (0,0) -- 
                plot[mark=triangle, mark options={fill=white}] (0.25,0)
                node[right]{DepQBF};
        \end{scope}

    \end{tikzpicture}
    \caption{spi}
    \label{fig:spi2}
\end{figure}

\begin{figure}
    \centering
    \begin{tikzpicture}[y=0.002cm, x=0.2cm]
        %axis
        \draw (0,0) -- coordinate (x axis mid) (50,0);
            \draw (0,0) -- coordinate (y axis mid) (0,4000);
            %ticks
            \foreach \x in {0,5,...,50}
                \draw (\x,1pt) -- (\x,-3pt)
                node[anchor=north] {\x};
            \foreach \y in {0,500,...,4000}
                \draw (1pt,\y) -- (-3pt,\y) 
                    node[anchor=east] {\y}; 
        %labels      
        \node[below=0.8cm] at (x axis mid) {Instance size ($| \mathcal{S} |$)};
        \node[rotate=90, above left=1cm and 1.5cm] at (y axis mid) {Time (seconds)};
        
        %Plots
        \draw plot[mark=o, mark size=2pt, mark options={fill=white,color=red}] file {data/bench_strat_ethernet_total.dat};
        \draw plot[mark=+, mark options={fill=white,color=blue}] file {data/bench_strat_ethernet_real.dat};

        \begin{scope}[shift={(5,2000)}] 
            \draw (0,0) -- 
                plot[mark=o, mark size=2pt, mark options={fill=white,color=red}] (0.25,0)
                node[right]{Bounded realisability};
            \draw[yshift=\baselineskip] (0,0) -- 
                plot[mark=x, mark options={fill=white,color=green}] (0.25,0)
                node[right]{Rareqs};
            \draw[yshift=2\baselineskip] (0,0) -- 
                plot[mark=+, mark options={fill=white,color=blue}] (0.25,0)
                node[right]{Termite};
            \draw[yshift=3\baselineskip] (0,0) -- 
                plot[mark=triangle, mark options={fill=white}] (0.25,0)
                node[right]{DepQBF};
        \end{scope}

    \end{tikzpicture}
    \caption{ethernet}
    \label{fig:ethernet2}
\end{figure}

\begin{figure}
\centering
\small
\begin{subfigure}{.5\linewidth}
  \centering
%%%  \includegraphics[width=\linewidth]{IDE.pdf}
  \caption{IDE}
  \label{fig:sub1}
\end{subfigure}%
~
\begin{subfigure}{.5\linewidth}
  \centering
%%%  \includegraphics[width=\linewidth]{UART.pdf}
  \caption{UART}
  \label{fig:sub2}
\end{subfigure}
\begin{subfigure}{.5\linewidth}
  \centering
%%%  \includegraphics[width=\linewidth]{SPI.pdf}
  \caption{SPI Flash}
  \label{fig:sub1}
\end{subfigure}%
~
\begin{subfigure}{.5\linewidth}
  \centering
%%%  \includegraphics[width=\linewidth]{Ethernet.pdf}
  \caption{Ethernet}
  \label{fig:sub2}
\end{subfigure}
\vspace{-3mm}
\caption{Performance of strategy extraction algorithm on four parameterised benchmarks.
The $X$-axis shows the number of state vars in the game.}
\vspace{-4mm}
\label{f:graphs}
\end{figure}

Table~\ref{table:res} shows a detailed breakdown of
experimental results, including the number of state variables for
each instance (\textbf{Vars}) and the total time taken by the
solver (\textbf{Total(s)}), split between the time used to 
determine the winner (and generate certificate trees) 
(\textbf{Base(s)}) and the strategy generation time 
(\textbf{Strategy(s)}).  The \textbf{OH} and \textbf{EffOH} 
columns show total and effective overheads introduced by the 
strategy generation step.

The \textbf{Size} column shows the size of the strategy, i.e., the 
number of $(W,a,k)$ tuples returned by the \textsc{GenLocalStrats}
function.  The last three columns report on our use of the PeRIPLO 
interpolation library in terms of the number of interpolation 
operations performed by the algorithm when solving the instance, 
the average and the maximal size of interpolants returned by 
PeRIPLO.  Numbers in brackets show the size of the interpolant 
compiled to a BDD.

\begin{table}[t]
\resizebox{\columnwidth}{!}{%
\begin{tabular}{r r r r r r r r r r}
\textbf{Vars} & \textbf{Total(s)} & \textbf{Base(s)} & \textbf{Strategy(s)} & \textbf{OH} & \textbf{EffOH} & \textbf{Size} & \textbf{INum} & \textbf{IAvg} & \textbf{IMax}  \\

\hline
\multicolumn{10}{c}{IDE benchmark} \\
\hline
26 & 32.62 & 25.42 & 7.20 & 1.28 & 1.16 & 50    & 48 & 1193 (23)     & 24155 (118)   \\
28 & 42.20 & 35.49 & 6.72 & 1.19 & 1.10 & 59    & 52 & 2489 (27)     & 39384 (119)   \\
30 & 60.04 & 51.93 & 8.11 & 1.16 & 1.08 & 92    & 43 & 72 (17)       & 1583 (148)    \\
32 & 115.11 & 107.35 & 7.77 & 1.07 & 1.04 & 60  & 36 & 18 (14)     & 85 (27)       \\
34 & 283.08 & 227.67 & 55.40 & 1.24 & 1.21 & 159& 49 & 2150 (15) & 103941 (38)   \\
\hline
\multicolumn{10}{c}{SPI benchmark} \\
\hline
15 & 0.35 & 0.26 & 0.09 & 1.36 & 1.26 & 8             & 5   & 11 (9) & 21 (9)   \\
22 & 0.94 & 0.72 & 0.22 & 1.31 & 1.19 & 15            & 12  & 10 (10) & 22 (18)  \\
29 & 2.46 & 1.90 & 0.56 & 1.29 & 1.16 & 22            & 17  & 12 (10) & 25 (18)  \\
36 & 3.56 & 2.91 & 0.65 & 1.22 & 1.11 & 107           & 22  & 11 (10) & 22 (18)  \\
43 & 9.11 & 7.09 & 2.03 & 1.29 & 1.13 & 166           & 27  & 11 (10) & 21 (14)  \\
50 & 16.20 & 12.85 & 3.35 & 1.26 & 1.12 & 233         & 32  & 11 (11) & 23 (18)  \\
57 & 25.00 & 19.86 & 5.14 & 1.26 & 1.12 & 322         & 37  & 12 (11) & 21 (18)  \\
64 & 38.48 & 31.48 & 7.00 & 1.22 & 1.10 & 416         & 42  & 12 (11) & 24 (18)  \\
71 & 57.88 & 47.94 & 9.94 & 1.21 & 1.09 & 70          & 47  & 12 (12) & 21 (18)  \\
78 & 91.51 & 75.02 & 16.49 & 1.22 & 1.10 & 636        & 52  & 12 (12) & 22 (19)  \\
85 & 141.10 & 116.71 & 24.39 & 1.21 & 1.09 & 773      & 57  & 13 (12) & 23 (20)  \\
92 & 193.96 & 162.05 & 31.91 & 1.20 & 1.09 & 917      & 62  & 13 (13) & 24 (21)  \\
99 & 309.44 & 256.88 & 52.55 & 1.20 & 1.09 & 1059     & 67  & 13 (13) & 22 (22)  \\
106 & 449.49 & 377.48 & 72.00 & 1.19 & 1.09 & 1223    & 72  & 13 (13) & 23 (23)  \\
113 & 1645.44 & 1543.84 & 101.60 & 1.07 & 1.03 & 117  & 77  & 14 (13) & 24 (24)  \\
120 & 901.95 & 830.17 & 71.77 & 1.09 & 1.04 & 1637    & 82  & 14 (14) & 25 (25)  \\
127 & 2259.65 & 2143.40 & 116.25 & 1.05 & 1.02 & 139  & 87  & 14 (14) & 26 (26)  \\
134 & 2385.74 & 2193.65 & 192.09 & 1.09 & 1.04 & 152  & 92  & 14 (14) & 27 (27)  \\
\hline
\multicolumn{10}{c}{Ethernet benchmarks} \\
\hline
14 & 0.06 & 0.03 & 0.02 & 1.60 & 1.52 & 2             & 1    & 24 (13)  & 24 (13)    \\
17 & 0.49 & 0.29 & 0.20 & 1.70 & 1.45 & 21            & 7    & 33 (16)  & 87 (30)    \\
20 & 1.97 & 1.14 & 0.82 & 1.72 & 1.45 & 176           & 15   & 41 (16)  & 110 (26)   \\
23 & 5.39 & 3.23 & 2.16 & 1.67 & 1.39 & 185           & 25   & 64 (23)  & 180 (42)   \\
26 & 14.61 & 7.94 & 6.66 & 1.84 & 1.48 & 266          & 36   & 100 (24) & 347 (45)   \\
29 & 27.41 & 15.71 & 11.70 & 1.74 & 1.43 & 677        & 44   & 155 (24) & 779 (48)   \\
32 & 58.02 & 35.38 & 22.64 & 1.64 & 1.36 & 208        & 61   & 136 (28) & 676 (55)   \\
35 & 111.69 & 69.26 & 42.43 & 1.61 & 1.35 & 351       & 80   & 141 (31) & 933 (75)   \\
38 & 238.09 & 151.21 & 86.89 & 1.57 & 1.33 & 545      & 116  & 184 (32) & 1081 (63)  \\
41 & 513.61 & 321.78 & 191.82 & 1.60 & 1.34 & 1525    & 154  & 184 (35) & 1123 (72)  \\
44 & 845.51 & 530.68 & 314.83 & 1.59 & 1.34 & 2159    & 191  & 276 (37) & 2253 (64)  \\
47 & 903.79 & 590.19 & 313.60 & 1.53 & 1.30 & 1547    & 228  & 261 (38) & 1780 (71)  \\
50 & 1368.23 & 875.90 & 492.33 & 1.56 & 1.33 & 1670   & 236  & 372 (38) & 2292 (85)  \\
\hline
\multicolumn{10}{c}{UART benchmarks} \\
\hline
15 & 2.86 & 2.19 & 0.67 & 1.31 & 1.19 & 12             & 40  & 28 (6)   & 90 (14)    \\
20 & 3.16 & 2.33 & 0.83 & 1.36 & 1.20 & 20             & 14  & 35 (12)  & 155 (23)   \\
21 & 10.06 & 6.96 & 3.09 & 1.44 & 1.24 & 35            & 34  & 48 (9)   & 306 (26)   \\
26 & 27.89 & 18.55 & 9.34 & 1.50 & 1.27 & 65           & 60  & 92 (13)  & 730 (41)   \\
27 & 63.68 & 41.49 & 22.20 & 1.53 & 1.29 & 93          & 94  & 96 (13)  & 825 (44)   \\
28 & 137.24 & 90.68 & 46.56 & 1.51 & 1.27 & 103        & 136 & 138 (13) & 1356 (42)   \\
29 & 270.66 & 178.75 & 91.92 & 1.51 & 1.27 & 134       & 184 & 212 (15) & 2806 (47)   \\
34 & 553.29 & 360.76 & 192.53 & 1.53 & 1.28 & 191      & 246 & 299 (16) & 6360 (54)   \\
35 & 938.68 & 612.63 & 326.05 & 1.53 & 1.28 & 285      & 307 & 258 (16) & 7949 (69)   \\
36 & 1525.99 & 995.25 & 530.74 & 1.53 & 1.28 & 410     & 382 & 348 (17) & 6408 (62)   \\
37 & 2464.13 & 1611.45 & 852.68 & 1.53 & 1.28 & 950    & 456 & 414 (18) & 10592 (75)  \\
38 & 3927.64 & 2577.39 & 1350.25 & 1.52 & 1.28 & 1223  & 546 & 504 (18) & 34431 (74)  \\
39 & 6030.77 & 4031.98 & 1998.79 & 1.50 & 1.26 & 674   & 633 & 608 (18) & 29996 (72)  \\
\hline
\end{tabular}}
\caption{Detailed experimental results.\label{table:res}}
\end{table}

Our results show that strategy generation adds a modest overhead
to the base solver.  Effective overheads are about $12\%$ for IDE
and SPI, about $35\%$ for Ethernet and about $30\%$ for UART.
Most of this overhead is due to interpolant computation.
Moreover, experiments show that our algorithm scales linearly with
the time taken by the base solver to determine the winner.

These results show that our algorithm is efficient, 
scalable and robust.  The last property is particularly 
interesting, as existing strategy extraction algorithms for 
traditional game solvers, based on winning set compilation, have 
been reported to introduce significant variance across 
instances~\cite{Bloem_KS_14corr,Bloem_KS_13}.  A conclusive 
comparison can only be performed by evaluating both types of 
algorithms on a common set of benchmarks.  Such a comparison 
requires first extending $\eva$ to support unbounded safety and 
reachability games and is part of the future work.

\section{Unbounded realisability}

We evaluate our approach on the benchmarks of the 2015 synthesis competition
(SYNTCOMP'15). Each benchmark comprises of controllable and uncontrollable
inputs to a circuit that assigns values to latches. One latch is configured as
the error bit that determines the winner of the safety game. The benchmark
suite is a collection of both real-world and toy specifications including
generalised buffers, AMBA bus controllers, device drivers, and converted LTL
formulas.  Descriptions of many of the benchmark families used can be found in
the 2014 competition report~\cite{jacobs2015}. 

The implementation of our algorithm uses \textsc{Glucose}~\cite{audemard2014}
for SAT solving and \textsc{Periplo}~\cite{rollini2013} for interpolant
generation. We intend to open source the tool for SYNTCOMP'16. The benchmarks
were run on a cluster of Intel Quad Core Xeon E5405 2GHz CPUs with 16GB of
memory.  The solvers were allowed exclusive access to a node for one hour to
solve an instance. 

The results of our benchmarking are shown, along with the synthesis competition
results~\cite{syntcompedacc}, in Table~\ref{tab:syntcomp}. The competition was
run on Intel Quad Core 3.2Ghz CPUs with 32GB of memory, also on isolated nodes
for one hour per instance. The competition results differ significantly from
our own benchmarks due to this more powerful hardware.  For our benchmarks we
report only the results for solvers we were able to run on our cluster. The
unique column lists the number of instances that only that tool could solve in
the competition (excluding our solver). In brackets is the number of instances
that only that tool could solve, including our solver.

\begin{table}
    \centering
    \setlength{\tabcolsep}{8pt}
    \begin{tabular}{l | r | r | r }
        \textbf{Solver} & \textbf{Solved} & \textbf{Solved} & \textbf{Unique} \\
                        & \textbf{(Competition)} & \textbf{(Benchmarks)} & \\
        \hline
        Simple BDD Solver (2) & 195 & 189 & 10 \textit{(6)} \\
        AbsSynthe (seq2) & 187 & 139 & 2 \\
        Simple BDD Solver (1) & 185 & 175 & \\
        AbsSynthe (seq3) & 179 & 134 & \\
        Realizer (sequential) & 179 & & \\
        AbsSynthe (seq1) & 173 & 139 & 1 \\
        Demiurge (D1real) & 139 & 136 & 5 \textit{(2)} \\
        Aisy & 98 & \\
        \textit{Unbounded Synthesis} & & \textit{103} & \textit{12} \\
    \end{tabular}
    \caption{Synthesis Competition 2015 Results}
    \label{tab:syntcomp}
\end{table}

Our implementation was able to solve 103 out of the 250 specification in the
alloted time, including 12 instances that were not solved by any other solver
in the sequential track of the competition. The unique instances we solved are
listed in Table~\ref{tab:unique}.

\begin{table}[h]
    \centering
    \setlength{\tabcolsep}{16pt}
    \begin{tabular}{l l}
        1. \texttt{6s216rb0\_c0to31} & 7. \texttt{driver\_c10n} \\
        2. \texttt{cnt30y} &  8. \texttt{stay18y} \\
        3. \texttt{driver\_a10n} & 9. \texttt{stay20n} \\
        4. \texttt{driver\_a8n} & 10. \texttt{stay20y} \\
        5. \texttt{driver\_b10y} & 11. \texttt{stay22n} \\
        6. \texttt{driver\_b8y} & 12. \texttt{stay22y} \\
    \end{tabular}
    \caption{Instances uniquely solved by our approach}
    \label{tab:unique}
\end{table}

Five of the instances unique to our solver are device driver instances and
another five are from the \texttt{stay} family. This supports the hypothesis
that different game solving methodologies perform better on certain classes of
specifications.

We also present a cactus plot of the number of instances solved over time
(Figure~\ref{fig:cactus}). We have plotted the best configuration of each
solver we benchmarked. The solvers shown are
\textsc{Demiurge}~\cite{bloem2014}, the only SAT-based tool in the competition,
the winner of the sequential realisability track \textsc{Simple BDD Solver
2}~\cite{walker2014}, and AbsSynthe (seq3) \cite{brenguier2014}.

\begin{figure}[h]
    \centering
    \begin{tikzpicture}[y=0.03cm, x=0.15cm]
        %axis
        \draw (0,0) -- coordinate (x axis mid) (60,0);
            \draw (0,0) -- coordinate (y axis mid) (0,200);
            %ticks
            \foreach \x in {0,10,...,60}
                \draw (\x,1pt) -- (\x,-3pt)
                node[anchor=north] {\x};
            \foreach \y in {0,25,...,200}
                \draw (1pt,\y) -- (-3pt,\y) 
                    node[anchor=east] {\y}; 
        %labels      
        \node[below=0.8cm] at (x axis mid) {Time (minutes)};
        \node[rotate=90, above left=1cm and 0.7cm] at (y axis mid) {Instances solved};
        
        %Plots
        \draw plot[mark=o, mark size=1pt, mark options={fill=white,color=red}] file {data/bench_termite.dat};
        \draw plot[mark=+, mark options={fill=white,color=blue}] file {data/bench_demiurge.dat};
        \draw plot[mark=triangle, mark options={fill=white}] file {data/bench_simple2.dat};
        \draw plot[mark=x, mark options={fill=white,color=green}] file {data/bench_abs1.dat};
%%%        \draw plot[mark=x, mark options={fill=white,color=green}] file {bench_abs2.dat};
%%%        \draw plot[mark=x, mark options={fill=white,color=green}] file {bench_abs3.dat};

        \begin{scope}[shift={(30,20)}] 
            \draw (0,0) -- 
                plot[mark=o, mark size=1pt, mark options={fill=white,color=red}] (0.25,0) -- (0.5,0) 
                node[right]{Unbounded synthesis};
            \draw[yshift=\baselineskip] (0,0) -- 
                plot[mark=x, mark options={fill=white,color=green}] (0.25,0) -- (0.5,0)
                node[right]{AbsSynthe (seq2)};
            \draw[yshift=2\baselineskip] (0,0) -- 
                plot[mark=+, mark options={fill=white,color=blue}] (0.25,0) -- (0.5,0)
                node[right]{Demiurge};
            \draw[yshift=3\baselineskip] (0,0) -- 
                plot[mark=triangle, mark options={fill=white}] (0.25,0) -- (0.5,0)
                node[right]{Simple BDD Solver 2};
        \end{scope}

    \end{tikzpicture}
    \caption{Number of instances solved over time.}
    \label{fig:cactus}
\end{figure}

Whilst our solver is unable to solve as many instances as other tools, it was
able to solve more unique instances than any solver in the competition. This
confirms that our methodology is able to fill gaps in a state of the art
synthesis toolbox by more efficiently solving instances that are hard for other
techniques. For this reason our solver would be a worthwhile addition to a
portfolio solver. In the parallel track of the competition, \textsc{Demiurge}
uses a suite of 3 separate but communicating solvers. The solvers
relay unsafe states to one another, which is compatible with the set $B^M$ in
our solver. This technique can already solve each of the unique instances
solved by our solver but there may still be value in the addition of this work
to the portfolio.  It remains future work to explore this possibility.
